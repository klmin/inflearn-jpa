# 트랜잭션 관련
- Read Uncommitted : commit, rollback 상관없이 변경내용 가져옴. Dirty Read 발생. 데이터 정합성에 문제가 생기는 격리 수준
  - Dirty Read : 트랜잭션의 작업이 완료되지 않았는데도 다른 트랜잭션에서 해당 데이터를 읽는 현상
  - Dirty Read, Non-repeatable Read, Phantom Read 모두 발생
- Read Committed : 트랜잭션이 commit, rollback 으로 완료되면 다른 트랜잭션에서 조회가 가능한 트랜잭션 격리 수준
  - Dirty Read가 발생하지 않으며, Undo영역의 백업된 레코드에서 값을 가져온다.
  - 많은 RDB 서비스에서 가장 많이 사용하는 트랜잭션 격리 수준. 하지만, Non-Repeatable Read가 발생한다.
  - Non-Repeatable Read : 한 트랜잭션 안에서 똑같은 SELECT 쿼리(read)를 실행했을 때 항상 같은 결과를 가져오지 않는 현상
    -  Lock을 통해 동시성을 제어하는 방식(lock-based concurrency control)에서는 SELECT 쿼리 실행 시에 read lock을 획득하지 않거나,
       획득한 lock이 SELECT 쿼리를 실행하자마자 해제될 때 발생
    - Non-Repeatable Read를 예방하는 방법
       - Transaction A가 commit이나 rollback이 될 때까지 Transaction B의 실행을 지연하는 것
       - Multiversion Concurrency Control(MVCC)을 사용
    - Non-Repeatable Read의 데이터 부정합 문제는 일반적인 서비스에서는 큰 문제가 되지 않지만, 금전을 다루는 서비스에서 특히 큰 문제가 발생
    - Dirty Read는 발생하지 않지만, Non-repeatable Read와 Phantom Read는 발생할 수 있음.
    - Undo 영역
      - 정의 : 트랜잭션 중에 변경된 데이터의 이전 상태(즉, 트랜잭션이 시작되기 전의 상태)를 저장하는 공간을 의미
      - 트랜잭션의 격리 수준에 사용될 뿐 아니라 트랜잭션 rollback이 발생했을 때 복구에도 사용
      - 하나의 레코드에 대한 여러 개의 백업이 존재할 수 있다. DBMS는 백업된 데이터가 불필요하다고 판단되는 시점에 주기적으로 삭제
      - 주요역할
        - 롤백 : 트랜잭션이 완료되지 않거나 롤백이 필요한 경우, UNDO 영역에 저장된 데이터를 사용하여 트랜잭션을 원래 상태로 복구
                 트랜잭션이 실패하면 UNDO 데이터를 사용하여 변경된 데이터를 취소하고 트랜잭션 이전 상태로 되돌린다.
        - 읽기 일관성 : 트랜잭션이 진행 중인 동안 다른 사용자나 세션에서 해당 데이터를 읽으려 할 때, 일관된 데이터를 제공하기 위해 UNDO 영역의 데이터를 사용
                       여러 트랜잭션이 동시에 진행될 때, 하나의 트랜잭션이 다른 트랜잭션의 중간 상태를 볼 수 없도록 보장한다.
                       트랜잭션이 진행 중인 데이터를 읽는 사용자에게는 트랜잭션이 완료되지 않았으므로 이전 상태를 제공
        - 플래시백 : UNDO 영역을 사용하여 데이터 복구를 지원
                     오라클 데이터베이스에서는 플래시백 쿼리 기능을 통해 과거의 데이터 상태를 조회하거나 복구할 수 있다.
      - 동작원리
        - 트랜잭션이 시작될 때, 데이터베이스는 변경 전 데이터를 UNDO 영역에 저장.
          트랜잭션이 완료되면, UNDO 데이터는 더 이상 필요하지 않으며, 새로운 트랜잭션을 위해 공간이 재사용될 수 있다.
          하지만 트랜잭션이 롤백되면 UNDO 데이터를 사용하여 데이터가 원래 상태로 복구된다.
        - 예시 : 사용자가 UPDATE 쿼리를 실행하여 데이터를 변경할 때, 데이터베이스는 변경된 데이터를 메인 테이블에 저장하고, 변경 전 데이터를 UNDO 영역에 기록
                 만약 해당 트랜잭션이 중간에 실패하거나 취소되어 ROLLBACK 명령을 실행하면, UNDO 영역의 데이터를 사용하여 데이터베이스는 변경 전 상태로 돌아간다.
      - UNDO와 Redo의 차이점
        - UNDO : 변경 전 데이터를 저장하여 트랜잭션을 롤백하거나 읽기 일관성을 보장하는 역할을 한다.
        - REDO : 변경 후 데이터를 저장하여, 시스템 오류 후에도 완료된 트랜잭션이 영구적으로 저장될 수 있도록 보장한다.
      - 요약 : UNDO 영역은 트랜잭션 중 변경된 데이터의 이전 상태를 저장하여 롤백, 읽기 일관성, 데이터 복구 등을 가능하게 하는 중요한 메커니즘
    - MVCC
      - 정의 : 데이터베이스에서 동시성 제어를 위해 사용되는 메커니즘. 동시에 여러 트랜잭션이 발생할 때, 트랜잭션 간의 충돌을 최소화하고
              데이터의 일관성을 유지하는데 도움을 준다. 여러 버전의 데이터를 유지함으로써, 읽기와 쓰기 작업을 동시에 처리할 수 있게 만든다.
      - 추가적인 저장공간이 필요하며 오래된 데이터 버전을 정리하는 과정이 필요
      - 주요특징
        - 여러 버전의 데이터 유지 : 데이터의 여러 버전을 관리함으로써, 읽기 작업과 쓰기 작업이 충돌 없이 동시에 수행될 수 있다.
          한 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션이 같은 데이터를 읽으려 하면, 수정 중인 데이터를 보지 않고 수정되기 전의 데이터 버전을 읽을 수 있다.
        - 읽기 일관성 : 각 트랜잭션이 시작될 때의 스냅샷을 사용하여, 트랜잭션이 수행되는 동안 데이터가 변경되어도 일관된 데이터를 제공
          "읽기 일관성"을 보장하여, 트랜잭션이 시작될 때 데이터를 읽으면 해당 트랜잭션이 끝날 때까지는 데이터가 변경되지 않은 것처럼 보인다.
        - 트랜잭션 격리 수준과의 관계 : PostgreSQL과 같은 데이터베이스에서 사용하는 기본 격리 수준인 Read Committed나 Repeatable Read에서 MVCC를 통해 읽기 일관성을 제공
        - 잠금(Locking) 최소화 : 전통적인 데이터베이스에서는 트랜잭션이 데이터를 읽거나 수정할 때 잠금(Locking)을 사용한다.
          그러나 MVCC는 잠금을 최소화하여 읽기 작업과 쓰기 작업을 독립적으로 처리할 수 있게 한다. 성능을 높이고, 대기 시간을 줄이는 데 기여
      - 동작방식
        - 쓰기 작업 : 데이터가 업데이트될 때, 기존 데이터를 삭제하거나 수정하는 대신 새로운 버전의 데이터를 생성합니다. 트랜잭션이 완료될 때까지는
                      다른 트랜잭션에서 해당 데이터를 수정할 수 없다.
        - 읽기 작업 : 트랜잭션이 시작될 때의 데이터 스냅샷을 기반으로 데이터를 읽습니다. 이로 인해 트랜잭션 중간에 다른 트랜잭션에서 데이터가 변경되더라도,
                     읽고 있는 트랜잭션은 변경된 데이터를 보지 않는다.
      - 장점
         - 동시성 향상 : 여러 트랜잭션이 동시에 수행될 수 있도록 하여, 데이터베이스의 성능을 향상시킨다.
         - 일관된 읽기: 트랜잭션 중간에 다른 트랜잭션이 데이터를 변경하더라도, 트랜잭션 시작 시점의 데이터 상태를 계속 읽을 수 있다.
         - 잠금 문제 해결: 읽기 작업은 쓰기 작업을 방해하지 않고 동시에 수행될 수 있다.
 - Repeatable Read : 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장하는 트랜잭션 격리 수준. MySQL의 InnoDB에서 기본으로 사용하는 트랜잭션 격리 수준
                     트랜잭션은 고유한 번호를 가지며 Undo 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.
                     하나의 트랜잭션 안에서 일어나는 모든 SELECT 쿼리는 자신의 트랜잭션 번호보다 작은 트랜잭션 번호에서 변경한 사항들만 볼 수 있다.
                     이러한 방식을 MVCC라고 한다.
   - Phantom Read라는 데이터 부정합 문제가 발생할 수 있다.
     - Phantom Read : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상. Non-Repeatable Read의 한 가지 경우
   - 트랜잭션 번호(스냅샷)와 Phantom Read의 관계
     - 트랜잭션 시작 시점의 데이터 스냅샷을 읽도록 보장한다.. 이 스냅샷은 트랜잭션 번호에 기반하여, 해당 트랜잭션이 시작될 때 존재하던 데이터의 상태를 유지한다.
       즉, 동일한 행을 반복해서 읽으면 동일한 결과를 보게 된다. 하지만 새로운 데이터 행이 삽입되거나 삭제되는 경우에는 스냅샷에 포함되지 않은
       새로운 행이 추가될 수 있다. Repeatable Read는 기존 행에 대해서는 일관된 읽기를 보장하지만, 새로 삽입된 행에 대한 일관성을 보장하지 않는다.
       이로 인해 팬텀 리드가 발생하게 됩니다. 즉, 행 수준의 잠금을 적용하지만, 삽입이나 삭제된 데이터 자체를 완전히 차단하지 않기 때문
   - Phantom Read 발생 이유
     - Repeatable Read는 기존 데이터 행에 대한 읽기와 쓰기 충돌을 방지한다. 즉, 트랜잭션이 이미 존재하는 행을 읽었을 때,
       다른 트랜잭션이 그 행을 수정하거나 삭제하는 것은 차단된다. 하지만 새로운 행의 삽입에 대해서는 차단하지 않기 때문에,
       트랜잭션이 실행되는 동안 다른 트랜잭션에서 새로운 데이터가 삽입되면, 해당 트랜잭션 내에서 같은 범위의 쿼리를 다시 실행할 때
       새로운 행이 나타날 수 있다. 이때 발생하는 것이 Phantom Read이다.
   - 예시
     - 트랜잭션 A가 SELECT * FROM employees WHERE age > 30을 실행해 5명의 직원을 조회한다.
       트랜잭션 B에서 나이가 35세인 새로운 직원을 삽입한다.
       트랜잭션 A가 다시 동일한 쿼리를 실행하면, 트랜잭션 A의 스냅샷에는 없었던 새로운 직원(35세 직원)이 조회된다.. 이때 팬텀 리드가 발생한다.
   - Dirty Read와 Non-repeatable Read는 방지되지만, Phantom Read는 발생할 수 있음
   - InnoDB는 갭 락과 넥스트키 락 덕분에 Repeatable Read에서도 Phantom Read를 예방할 수 있다.
  - Serializable
    - 모든 작업을 하나의 트랜잭션에서 처리하는 것과 같이 동작하는 가장 높은 트랜잭션 격리 수준
    - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
    - Phantom Read 문제가 발생하지 않습니다. 하지만, Deadlock에 걸릴 가능성이 존재하고 동시성 처리 성능이 저하되기 때문에 신중하게 사용해야 한다.
  - 트랜잭션 격리 수준과 발생 가능 문제
    </br> ![image](https://github.com/user-attachments/assets/0c7f7482-ee1f-4788-a913-5873396113cb)
