# 영속성 컨텍스트 1

JPA 에서 가장 중요한 2가지
1. 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping)
2. 영속성 컨텍스트

엔티티 매니저 팩토리와 엔티티 매니저
- 요청이올때마다 entityManagerFactory에서 entiyManager를 생성함.

![image](https://github.com/user-attachments/assets/399829ae-913e-4743-bc9d-84212d829d54)

영속성 컨텍스트 
1. JPA를 이해하는데 가장 중요한 용어
2. "엔티티를 영구저장하는 환경"이라는 뜻
3. EntityManager.persist(entity); - entity를 db에 저장한다는게 아니라 영속성컨텍스트에 저장한다.
4. 영속성 컨텍스트는 논리적인 개념
5. 눈에 보이지 않는다.
6. 엔티티매니저를 통해서 영속성컨텍스트에 접근
7. PersistenceContext - entiyManager (엔티티매니저와 영속성컨텍스트가 N:1)

# 엔티티의 생명주기
비영속(new/transient)
- 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 객체를 생성한 상태(비영속)
  ex) Member member = new Member();
      member.setId(1);
      member.setName("test");
  
영속(managed)
- 영속성 컨텍스트에 관리되는 상태 ex) entityManager.persist
- 객체를 저장한 상태(영속)
  ex) em.persist(member);
  트랜잭션이 commit 하는 시점에 db에 쿼리가 나감
  
준영속(detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태
- 엔티티를 영속성 컨텍스트에서 분리(준영속)
  ex) em.detach(member);
  
삭제(removed)
- 삭제된 상태
- 객체를 삭제한상태(삭제)
  ex) em.remove(member);

영속성 컨텍스트의 이점
1. 1차캐시
2. 동일성(identity) 보장
3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
4. 변경 감지(dirty checking)
5. 지연로딩(lazy loading)

# 영속성 컨텍스트 2

![image](https://github.com/user-attachments/assets/d567f587-b27f-4928-a598-9082352142de)

db pk로 맵핑한게 1차 캐시에 key가 되고 객체 자체가 value가됨
em.find 호출시 1차캐시를 먼저 검색함. 있으면 db조회안하고 return

1차 캐시에 없을때) em.find -> 1차캐시조회 -> db조회 -> 1차캐시에 저장 -> 반환
1차 캐시에 있을때) em.fi -> 1차캐시조회 -> 반환

* 영속성 컨텍스트는 트랜잭션 단위로 생성되고 종료됨

* 영속성 엔티티의 동일성 보장
 - 1차캐시로 반복가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

  Member member = em.find(1);
  Member member2 = em.find(1);
  if(member == member2) - true

![image](https://github.com/user-attachments/assets/c8c8c6a6-c476-4631-8d1d-b95096f7b86d)
![image](https://github.com/user-attachments/assets/0c410ffb-6fbb-4fe9-8793-291e77ab2d57)

* 트랜잭션을 지원하는 읽기 쓰기
 - em.persist(memberA); - 1차캐시에 들어감. jpa가 entity를 분석해서 insert 쿼리를 생성하고 쓰기지연 SQL 저장소에 넣음
   em.persist(memberB); - 1차캐시에 들어감. jpa가 entity를 분석해서 insert 쿼리를 생성하고 쓰기지연 SQL 저장소에 넣음
   insert sql을 db에 보내지 않는다.
   트랜잭션 commit시 db에 쿼리를 전송한다. - commit시 쓰기지연 SQL 저장소에 있던 쿼리가 DB로 flsh 되고 commit됨됨

jpa는 기본생성자 하나 있어야함. 내부에서 리플렉션을 씀. public 아니여도됨





  
